using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Threading;

namespace SBPSearcher {
    public class Program {
        public static bool IsUpdatingConsole=false;
        public static bool F2AlreadyPressed=false;
        public static string[] files;
        static void Main(string[] args) {

            Console.WriteLine("SBPSearcher- the program to settle the question once and for all!");
            Console.WriteLine("Please enter in the width and height of the board.");
            Console.Write("Width: ");
            byte.TryParse(Console.ReadLine(), out Globals.x);
            if (Globals.x == 0) {
                Console.WriteLine("Okay, I have no idea what you just typed in.");
                Console.WriteLine("That was a fatal error.");
                Environment.Exit(0);
            }

            Console.Write("Height: ");
            byte.TryParse(Console.ReadLine(), out Globals.y);
            if (Globals.y == 0) {
                Console.WriteLine("Okay, I have no idea what you just typed in.");
                Console.WriteLine("That was a fatal error.");
                Environment.Exit(0);
            }

            Console.WriteLine("Lastly, the directory containing the files you want to solve.");
            Console.WriteLine("(This is typically generated by programs like SBPSORTER)");
            string dirname = Console.ReadLine();

            Puzzles.x = Globals.x;
            Puzzles.y = Globals.y;
            Puzzles.xy = Puzzles.x * Puzzles.y;

            String filename = "results-" + DateTime.Now.Year + "-" + DateTime.Now.Month + "-" + DateTime.Now.Day + "_" + DateTime.Now.Hour + "-" + DateTime.Now.Minute + "-" + DateTime.Now.Second + ".txt";
            Puzzles.tw = new StreamWriter(filename);


            //Solver.SolveBoard(new List<byte[,]>() { new byte[,] { { 1, 0,2, 3 }, { 0,1, 2, 3 }, { 0, 4, 4, 4 }, { 0, 0, 4, 5 } } }, solveType.Solve, 15, 1, true, new byte[]{1});
            SearchForPuzzles(dirname);
            Puzzles.tw.Close();

            Console.WriteLine("Done! Puzzles have been written to {0}", filename);
            Console.ReadLine();
        }

        
        static void SearchForPuzzles(string dirname) {
            //This does all the work. Basically, it makes a HashSet with all the end positions, counts them, and then proceeds to find the hardest end-position
            //to start-position, that is, solving the group associated with the end position loaded.

            //The main algorithm in this function also needs to detect the other end positions in this group (by doing a diameter search), and remove them from the HashSet or otherwise mark them as solved.

            //Here's the (conjectured) algorithm for finding an element in a group S which is furthest away from any nodes in a set F:
            //Oh darn, the idea I had for it doesn't work!

            //New approach:
            //dl=-100;
            //dn=-1;
            //F=readpoint
            //S=null
            //S2=null
            //Repeat until dl>=dn:
            //Find_furthest (F->S); //At this step remove all Fs from hashset
            //dl=dn;
            //S2=S
            //dn=solve(S->F)
            //end repeat
            //return S2,dl

            //This works much better:
            //Do diameter search
            //Do end solve

            
            files = Directory.GetFiles(dirname);
            Array.Sort(files, IsGreaterThan);

            Console.WriteLine("How many threads should I run? Default: 1");
            int numthreads = 1;
            if(!int.TryParse(Console.ReadLine(),out numthreads)){
                numthreads=1;
            }
            Console.WriteLine("Running with {0} threads",numthreads);
            Console.WriteLine("Press F2 to toggle verbosity...");
            Thread[] threads = new Thread[numthreads];

            int nextFile = 0;
            while (nextFile < files.Length) {
                for (int i = 0; i < threads.Length; i++) {
                    if ((threads[i]==null)||!threads[i].IsAlive) {
                        //copy variables due to thread finickyness
                        int threadnum = i;
                        int filenum = nextFile;
                        string filename = files[filenum];
                        threads[i] = new Thread(new ThreadStart(delegate { Searcher searcher = new Searcher(); searcher.SearchFile(filename, filenum,threadnum); }));
                        threads[i].Start();
                        nextFile++;
                        break;
                    }
                }

                Thread.Sleep(10);
            }

            bool isDone = false;
            while (!isDone) {
                isDone = true;
                for (int i = 0; i < threads.Length; i++) {
                    if ((threads[i] != null) && threads[i].IsAlive) {
                        isDone = false;
                    }
                }
                Thread.Sleep(10);
            }

        }

        static void CheckKeyboard() {
            if (Console.KeyAvailable) {
                ConsoleKeyInfo cki = Console.ReadKey(false);
                if (cki.Key == ConsoleKey.F2) {
                    if (!F2AlreadyPressed) {
                        IsUpdatingConsole = !IsUpdatingConsole;
                    }
                    F2AlreadyPressed = true;
                }
            } else {
                F2AlreadyPressed = false;
            }
        }

        static int IsGreaterThan(string a, string b) {
            if (a == b) {
                return 0;
            }
            if (a.Contains('\\')) {
                a = a.Substring(a.LastIndexOf('\\'));
                //then b does too
                b = b.Substring(b.LastIndexOf('\\'));
            }
            string p1 = a.Substring(0, a.IndexOf("-"));
            string p2 = b.Substring(0, b.IndexOf("-"));

            if (p1.Length > p2.Length) {
                return 1;
            }
            if (p1.Length < p2.Length) {
                return -1;
            }
            if (p1 != p2) {
                return p1.CompareTo(p2) > 0 ? 1 : -1;
            }
            return IsGreaterThan(a.Substring(a.IndexOf("-") + 1), b.Substring(b.IndexOf("-") + 1));
        }
    }
    class Searcher{

        //You can override
        //these functions to make them do
        //what you want them to
        public byte[] FindEndingPieces(byte[,] tab) {
            //Finds and returns the goal pieces, if such a piece exists.

            
            List<byte> a = new List<byte>(Puzzles.x);
            List<byte> b = new List<byte>(Puzzles.y);
            for (int i = Puzzles.x - 1; i >= 0; i--) {
                if (tab[Puzzles.y - 1, i] > 0) {
                    a.Add(tab[Puzzles.y - 1, i]);
                }
            }
            for (int i = Puzzles.y - 1; i >= 0; i--) {
                if (tab[i, Puzzles.x - 1] > 0) {
                    b.Add(tab[i, Puzzles.x - 1]);
                }
            }
            return a.Intersect(b).ToArray();
            //return tab[Puzzles.y - 1, Puzzles.x - 1];
        }

        static int GetBeginningSquare(int width, int height) {
            //return ((Puzzles.x - width) / 2);
            return 0;
        }

        static bool IsAcceptableStart(byte[,] board) {
            //check symmetry
            return true;
        }

        bool True(byte[,] whatevs) {
            return true;
        }

        /// <summary>
        /// Utility function only.
        /// </summary>
        /// <param name="puz">An ending puzzle in the group.</param>
        /// <param name="endpos">The starting position of the piece. Use -1 for any position, and -2 for automatic.</param>
        public void SearchSinglePuzzle(byte[,] puz, int endpos, bool verbose) {
            Solver s = new Solver();
            byte piece;
            byte[] possPieces;
            int pieceposition;
            int pwidth;
            int pheight;
            possPieces = FindEndingPieces(puz);
            for (int np = 0; np < possPieces.Length; np++) {
                piece = possPieces[np];
                pieceposition = 0;
                //Find the ending piece position.
                for (int y = 0; y < Puzzles.y; y++) {
                    for (int x = 0; x < Puzzles.x; x++) {
                        if (puz[y, x] == piece) {
                            pieceposition = (Puzzles.x * y + x);
                            goto exit; //I'm so so sorry.

                        }
                    }
                }
            exit:
                s.SolveBoard(new List<byte[,]>() { puz }, solveType.AllNonSpecificSolutions, pieceposition, piece, Verbosity.Quiet, new byte[] { piece },True);
                pwidth = 0;
                pheight = 0;
                for (int y = 0; y < Puzzles.y; y++) {
                    for (int x = 0; x < Puzzles.x; x++) {
                        if (puz[y, x] == piece) {
                            if (Puzzles.y - y > pheight) {
                                pheight = Puzzles.y - y;
                            }
                            if (Puzzles.x - x > pwidth) {
                                pwidth = Puzzles.x - x;
                            }
                        }
                    }
                }
                switch (endpos) {
                    case -1:
                        s.SolveBoard(s.results, solveType.Diameter, pieceposition % Puzzles.x + pwidth - Puzzles.x, piece, Verbosity.Quiet, new byte[] { piece }, True);
                        break;
                    case -2:
                        s.SolveBoard(s.results, solveType.AllSolutions, pieceposition % Puzzles.x + pwidth - Puzzles.x, piece, Verbosity.Quiet, new byte[] { piece },True); //That's nontrivial to come by randomly.
                        break;
                    default:
                        s.SolveBoard(s.results, solveType.AllSolutions, endpos, piece, Verbosity.Quiet, new byte[] { piece }, True);
                        break;
                }


                //Take the last board. That's the result.
                Console.WriteLine("Group done! Best puzzle:");
                if (s.results.Count != 0) {
                    Console.WriteLine(p_t_str(s.results.Last()));
                    Console.WriteLine("With " + s.resultnum.ToString() + " moves");
                } else {
                    Console.WriteLine("Nothing!");
                }
            }

        }

        public void SearchFile(string file, int filenum, int threadnum) {
            HashSet<byte[,]> boards;
            HashSet<byte[,]> newboards;
            long maxMoves = 0;
            String maxPuzzle = "";
            int maxGoalPieces = 1;
            int currentGoalPiece = 0;
            byte[] readpuz = new byte[Puzzles.xy];
            byte[,] currentPuzzle;
            byte[,] parsepuzzle;
            int pieceposition = 0;
            byte piece;
            Solver s = new Solver();

            BinaryReader tr = new BinaryReader(File.OpenRead(file));
            //Populate the hashset.
            ArrayComparer ac = new ArrayComparer();
            boards = new HashSet<byte[,]>(ac);
            newboards = new HashSet<byte[,]>(ac);

            int bytesRead = tr.Read(readpuz, 0, Puzzles.xy);
            while (bytesRead == Puzzles.xy) {
                newboards.Add(bin_t_puz(readpuz));
                bytesRead = tr.Read(readpuz, 0, Puzzles.xy);
            }

            while (currentGoalPiece < maxGoalPieces) {
                boards = new HashSet<byte[,]>(newboards, ac);
                newboards.Clear();
                while (boards.Count != 0) {
                    currentPuzzle = boards.First();

                    byte[] possPieces = FindEndingPieces(currentPuzzle);
                    if (possPieces.Length > maxGoalPieces) {
                        maxGoalPieces = possPieces.Length;
                    }
                    if (currentGoalPiece >= possPieces.Length) {
                        boards.Remove(currentPuzzle);
                    } else {
                        piece = possPieces[currentGoalPiece];
                        //Find the ending piece position.
                        for (int y = 0; y < Puzzles.y; y++) {
                            for (int x = 0; x < Puzzles.x; x++) {
                                if (currentPuzzle[y, x] == piece) {
                                    pieceposition = Puzzles.x * y + x;
                                    goto exit; //I'm so so sorry.

                                }
                            }
                        }
                    exit:
                        s.SolveBoard(new List<byte[,]>() { currentPuzzle }, solveType.AllNonSpecificSolutions, pieceposition, piece,
                            Program.IsUpdatingConsole ? Verbosity.Quiet : Verbosity.Silent, new byte[] { piece },True);
                        //Parse and remove all puzzles from the file.

                        if (Puzzles.IsParsing) {
                            Thread.Sleep(0);
                        }
                        Puzzles.IsParsing = true;
                        foreach (byte[,] puz in s.results) {
                            //puzstr = p_t_str(puz);
                            parse(puz_t_par(puz));//DURR.
                            parsepuzzle = par_t_puz();
                            ArrayComparer arc = new ArrayComparer();
                            if (boards.Contains(parsepuzzle)) {
                                boards.Remove(parsepuzzle);
                                int nump = FindEndingPieces(parsepuzzle).Length;
                                if (nump > currentGoalPiece + 1) {
                                    if (nump > maxGoalPieces) { //is this necessary?
                                        maxGoalPieces = nump;
                                    }
                                    if (!newboards.Contains(parsepuzzle)) {
                                        newboards.Add(parsepuzzle);
                                    }
                                }
                            }
                        }
                        Puzzles.IsParsing = false;

                        // Step 2 of the algorithm. (Not so simple NOW, is it?)
                        //Calculate width & height of piece in lower-right.
                        //Could be made faster.
                        int left = Puzzles.x;
                        int right = 0;
                        int top = Puzzles.y;
                        int btm = 0;
                        for (int y = 0; y < Puzzles.y; y++) {
                            for (int x = 0; x < Puzzles.x; x++) {
                                if (currentPuzzle[y, x] == piece) {
                                    if (x < left) left = x;
                                    if (x > right) right = x;
                                    if (y < top) top = y;
                                    if (y > btm) btm = y;
                                }
                            }
                        }
                        int offset = pieceposition - (Puzzles.x * top + left);
                        s.SolveBoard(s.results, solveType.AllSolutions, offset+GetBeginningSquare(right-left+1,btm-top+1), piece,
                            Program.IsUpdatingConsole ? Verbosity.Quiet : Verbosity.Silent, new byte[] { piece },IsAcceptableStart);
                        //Take the last board that satisfies the IsAcceptableStart condition. That's the result.
                        //Console.WriteLine("Group done! Best puzzle:");

                        int score = 0;

                        if (s.results.Count != 0) {
                            byte[,] scorepuz = s.results.Last();
                            score = s.resultnum;
                            if (Program.IsUpdatingConsole) {
                                Console.WriteLine(p_t_str(scorepuz));
                                Console.WriteLine("With {0} score", score);
                            }
                            if (score > maxMoves) {
                                maxMoves = score;
                                maxPuzzle = p_t_str(scorepuz);
                            }

                        } else {
                            if (Program.IsUpdatingConsole) {
                                Console.WriteLine("Nothing!");
                            }
                        }


                        if (Program.IsUpdatingConsole) {
                            Console.WriteLine("Best score so far: {0} with score of {1}", maxPuzzle, maxMoves);
                            Console.WriteLine("{0} more to go in file, round {1} / {2},  {3} / {4} files completed", boards.Count, currentGoalPiece + 1, maxGoalPieces, filenum, Program.files.Length);
                        }
                        
                    }
                }

                currentGoalPiece++;
            }


            //Write best puzzle and alert user
            while (Puzzles.IsWriting) {
                Thread.Sleep(10);
            }
            Puzzles.IsWriting = true;
            Puzzles.tw.WriteLine(file);
            Puzzles.tw.WriteLine(maxMoves);
            Puzzles.tw.WriteLine(maxPuzzle);
            Puzzles.tw.WriteLine();
            Puzzles.tw.Flush();
            Console.WriteLine("(thread {2}) File {0} completed! Best puzzle had {1} moves", filenum, maxMoves,threadnum);
            Puzzles.IsWriting = false;
            Console.Beep();
        }

        public byte[] range(byte a, byte b) {
            byte[] result = new byte[b - a + 1];
            for (byte i = a; i <= b; i++) {
                result[i - a] = i;
            }
            return result;
        }

        public byte[,] str_t_p(string puz) {
            //String to puzzle.
            byte[,] result = new byte[Puzzles.y, Puzzles.x];
            for (int y = 0; y < Puzzles.y; y++) {
                for (int x = 0; x < Puzzles.x; x++) {
                    result[y, x] = CharToByte(puz[2 * (Puzzles.x * y + x)]);
                }
            }
            return result;
        }
        public string p_t_str(byte[,] puz) {
            StringBuilder sb = new StringBuilder();
            for (int y = 0; y < Puzzles.y; y++) {
                for (int x = 0; x < Puzzles.x; x++) {
                    sb.Append(puz[y, x]);
                    sb.Append(" ");
                }
            }
            return sb.ToString();

        }
        public byte[,] par_t_puz() {
            //Turns the parsed puzzle into a proper 2D puzzle.
            byte[,] result = new byte[Puzzles.y, Puzzles.x];
            for (int y = 0; y < Puzzles.y; y++) {
                for (int x = 0; x < Puzzles.x; x++) {
                    result[y, x] = Puzzles.curparse[Puzzles.x * y + x];
                }
            }
            return result;
        }
        public byte[] puz_t_par(byte[,] puz) {
            //Turns a 2D puzzle into a "parsed" puzzle (not really)
            byte[] result = new byte[Puzzles.xy];
            for (int y = 0; y < Puzzles.y; y++) {
                for (int x = 0; x < Puzzles.x; x++) {
                    result[Puzzles.x * y + x] = puz[y, x];
                }
            }
            return result;
        }
        public void parse(byte[] puz) {
            //Parser version 3. No bugs here!
            //Given a DE-ENCODED string, this routine parses it.
            /*
             * i.e 1 0 2 0 3 3 0 9 7->
             * 102
             * 033
             * 097
             * ->
             * 102
             * 033
             * 045
             * */

            Puzzles.curhigh = 1;
            Puzzles.curparse = new byte[Puzzles.xy]; //Defaulted to all 0s.
            List<Int32> nodes = new List<Int32>(); //number->position. Simple BFS. 
            Int32[] arpuz = new Int32[Puzzles.xy];
            int a;
            puz.CopyTo(arpuz, 0);

            for (Int32 i = 0; i < (Puzzles.xy); i = i + 1) {

                a = arpuz[i]; //The value we want.
                if ((arpuz[i] != 0) && (Puzzles.curparse[i] == 0)) //If it isn't zero & we haven't met it before
                {

                    nodes.Add((Byte)i);
                    Int32 count = 1;
                    Int32 position;
                    Puzzles.curparse[i] = Puzzles.curhigh;
                    while (count != 0) //While there are still nodes to visit
                    {
                        position = nodes[0];
                        if (position % Puzzles.x != 0) //If it's not on the left side
                        {
                            if ((arpuz[position - 1] == a) && (Puzzles.curparse[position - 1] == 0)) //If it's the same and we haven't seen it before (to prevent an inf. loop)
                            {
                                //Set the array position
                                Puzzles.curparse[position - 1] = Puzzles.curhigh;
                                //Add the node
                                nodes.Add(position - 1);
                                count++;
                            }

                        }
                        if (position % Puzzles.x != Puzzles.x - 1) //If it's not on the right side
                        {
                            if ((arpuz[position + 1] == a) && (Puzzles.curparse[position + 1] == 0)) {
                                Puzzles.curparse[position + 1] = Puzzles.curhigh;
                                nodes.Add((Byte)(position + 1));
                                count++;
                            }
                        }
                        if (position >= Puzzles.x) //If it's not on the bottom
                        {
                            if ((arpuz[position - Puzzles.x] == a) && (Puzzles.curparse[position - Puzzles.x] == 0)) {
                                Puzzles.curparse[position - Puzzles.x] = Puzzles.curhigh;
                                nodes.Add((Byte)(position - Puzzles.x));
                                count++;
                            }
                        }
                        if (position < Puzzles.xy - Puzzles.x) //If it's not on the top
                        {
                            if ((arpuz[position + Puzzles.x] == a) && (Puzzles.curparse[position + Puzzles.x] == 0)) {
                                Puzzles.curparse[position + Puzzles.x] = Puzzles.curhigh;
                                nodes.Add(position + Puzzles.x);
                                count++;
                            }
                        }
                        nodes.RemoveAt(0); //Delete the node; we're done with it.
                        count--;
                    }
                    Puzzles.curhigh++;
                }
                //All of the positions for a should now be placed in Puzzles.curparse.



            }
        }


        //Unkersplat.
        public byte[,] bin_t_puz(byte[] bin) {
            byte[,] result = new byte[Puzzles.y, Puzzles.x];
            for (int y = 0; y < Puzzles.y; y++) {
                for (int x = 0; x < Puzzles.x; x++) {
                    result[y, x] = bin[Puzzles.x * y + x];
                }
            }
            return result;
        }
        //The next 2 algorithms are borrowed from SBPFinder. They're to check whether the "OOPS"es are any problem.
        public Boolean CanMoveUp(byte[] board, byte piece) {
            //Note: there are faster ways to do this involving arrays for each piece and other things like that.
            //These algorithms are contained within the latest version of SSBPSolver; for now, this is good enough.

            for (int i = 0; i < board.Length; i++) {
                if (board[i] == piece) {
                    if (i < Puzzles.x) {
                        return false;
                    } else {
                        if (!((board[i - Puzzles.x] == 0) || (board[i - Puzzles.x] == piece))) //This could be 1 or 2 instructions faster.
                        {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        public Boolean CanMoveLeft(byte[] board, byte piece) {
            for (int i = 0; i < board.Length; i++) {
                if (board[i] == piece) {
                    if (i % Puzzles.x == 0) {
                        return false;
                    } else {
                        if (!((board[i - 1] == 0) || (board[i - 1] == piece))) //This could be 1 or 2 instructions faster.
                        {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        public byte CharToByte(char val) {
            byte ret = (byte)val;
            if (48 <= ret && ret <= 57) {
                return (byte)(ret - 48); // 0 to 9
            }
            if (97 <= ret && ret <= 122) {
                return (byte)(ret - 87);//10 to 35
            }
            if (65 <= ret && ret <= 90) {
                return (byte)(ret - 29); //36 to 61
            }
            return 0;
        }
        public bool ArrayEquals(byte[,] x, byte[,] y) {
            //Tests whether two arrays are equivalent.
            for (int i = 0; i < Puzzles.x; i++) {
                for (int j = 0; j < Puzzles.y; j++) {
                    if (x[j, i] != y[j, i]) {
                        return false;
                    }
                }
            }

            return true;


        }

    }
    public class Puzzles //Just a global class, to appease the parser.
    {
        public static bool IsParsing;
        public static byte curhigh;
        public static byte[] curparse;
        public static int xy;
        public static int x;
        public static int y;

        public static bool IsWriting;
        public static TextWriter tw;
    }

    public class ArrayComparer : IEqualityComparer<byte[,]> {
        public bool Equals(byte[,] x, byte[,] y) {
            //Tests whether two arrays are equivalent.
            for (int i = 0; i < Puzzles.x; i++) {
                for (int j = 0; j < Puzzles.y; j++) {
                    if (x[j, i] != y[j, i]) {
                        return false;
                    }
                }
            }

            return true;


        }
        public int GetHashCode(byte[,] obj) {
            //Quick 'n simple array hash code generator.
            int ret = 0;
            //int mret;
            //int numMax;

            for (int y = 0; y < Puzzles.y; y++) {
                for (int x = 0; x < Puzzles.x; x++) {
                    ret = (ret * 17 + obj[y, x] + 1); //Primes should probably be larger.
                }
            }

            return ret;
        }
    }
}
